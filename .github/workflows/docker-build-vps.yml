name: Build Docker on VPS

# Trigger do workflow
on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch: # Permite executar manualmente
    inputs:
      action_type:
        description: 'Tipo de ação a executar'
        required: true
        type: choice
        options:
          - build-and-deploy
          - build-only
        default: 'build-and-deploy'
      environment:
        description: 'Ambiente de deploy (DEV ou PRD)'
        required: true
        type: choice
        options:
          - PRD
          - DEV
        default: 'PRD'

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    
    # Definir permissões mínimas necessárias para o GITHUB_TOKEN
    permissions:
      contents: read  # Para fazer checkout do código
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
      
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Para push/PR, usar PRD por padrão
            echo "environment=PRD" >> $GITHUB_OUTPUT
          fi
      
      - name: Create .env file
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          
          # Selecionar secrets baseado no ambiente
          if [ "$ENV" == "DEV" ]; then
            DATABASE_URL=${{ secrets.DATABASE_URL_DEV || secrets.DATABASE_URL }}
            NODE_ENV=development        
          else
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            NODE_ENV=${{ secrets.NODE_ENV || 'production' }}     
          fi
          NEXT_TELEMETRY_DISABLED="${{ secrets.NEXT_TELEMETRY_DISABLED || '1' }}"

          cat > .env << ENVEOF
          DATABASE_URL="${DATABASE_URL}"
          NODE_ENV="${NODE_ENV}"
          NEXT_TELEMETRY_DISABLED="${NEXT_TELEMETRY_DISABLED}"
          ENVEOF
          
          # Adicionar secrets opcionais se estiverem definidos
          if [ -n "$NEXTAUTH_SECRET" ]; then
            echo "NEXTAUTH_SECRET=\"${NEXTAUTH_SECRET}\"" >> .env
          fi
          
          if [ -n "$NEXTAUTH_URL" ]; then
            echo "NEXTAUTH_URL=\"${NEXTAUTH_URL}\"" >> .env
          fi
          
          if [ -n "$API_KEY" ]; then
            echo "API_KEY=\"${API_KEY}\"" >> .env
          fi
      
      - name: Build Docker Image
        run: |
          if [ "$ENVIRONMENT" == "DEV" ]; then
            CONTAINER_NAME="azevedo-site-dev"
          else
            CONTAINER_NAME="azevedo-site"
          fi
          docker build -t $CONTAINER_NAME:${{ github.sha }} -t $CONTAINER_NAME:latest .
      
      - name: Save and Transfer Docker Image to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
        run: |
          # Criar tarball da imagem
          if [ "$ENVIRONMENT" == "DEV" ]; then
            CONTAINER_NAME="azevedo-site-dev"
          else
            CONTAINER_NAME="azevedo-site"
          fi
          docker save $CONTAINER_NAME:latest | gzip > $CONTAINER_NAME.tar.gz
          
          # Transferir imagem e .env para o VPS
          scp -i ~/.ssh/id_rsa $CONTAINER_NAME.tar.gz $VPS_USER@$VPS_HOST:/tmp/
          scp -i ~/.ssh/id_rsa .env $VPS_USER@$VPS_HOST:/tmp/
      
      - name: Load Image and Push to Registry on VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          REGISTRY_HOST: ${{ secrets.REGISTRY_HOST || secrets.VPS_HOST }}
          REGISTRY_PORT: ${{ secrets.REGISTRY_PORT || '5000' }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          if [ "$ENVIRONMENT" == "DEV" ]; then
            CONTAINER_NAME="azevedo-site-dev"
          else
            CONTAINER_NAME="azevedo-site"
          fi
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST "bash -s" << EOF
            set -e
            
            # Navegar para o diretório do projeto
            cd "$VPS_PATH"
            
            # Carregar a imagem do tarball
            echo "Loading Docker image..."
            gunzip -c /tmp/$CONTAINER_NAME.tar.gz | sudo docker load
            
            # Taguear para o registry local
            REGISTRY="$REGISTRY_HOST:$REGISTRY_PORT"
            sudo docker tag $CONTAINER_NAME:latest \$REGISTRY/$CONTAINER_NAME:latest
            sudo docker tag $CONTAINER_NAME:latest \$REGISTRY/$CONTAINER_NAME:$COMMIT_SHA
            
            # # Configurar registry como insecure (HTTP) se necessário
            # REGISTRY_ADDR="$REGISTRY_HOST:$REGISTRY_PORT"
            
            # # Verificar se já está configurado
            # if [ -f /etc/docker/daemon.json ] && grep -q "\"$REGISTRY_ADDR\"" /etc/docker/daemon.json 2>/dev/null; then
            #   echo "Registry $REGISTRY_ADDR already configured as insecure"
            # else
            #   echo "Configuring Docker to allow insecure registry $REGISTRY_ADDR..."
              
            #   # Configurar registry como insecure usando jq
            #   if [ -f /etc/docker/daemon.json ]; then
            #     sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak
            #     # Add registry to insecure-registries array, creating array if needed, ensuring uniqueness
            #     sudo jq --arg registry "$REGISTRY_ADDR" \
            #       'if .["insecure-registries"] then .["insecure-registries"] |= (. + [$registry] | unique) else .["insecure-registries"] = [$registry] end' \
            #       /etc/docker/daemon.json > /tmp/daemon.json.tmp
            #     sudo mv /tmp/daemon.json.tmp /etc/docker/daemon.json
            #   else
            #     echo "{\"insecure-registries\":[\"$REGISTRY_ADDR\"]}" | sudo tee /etc/docker/daemon.json > /dev/null
            #   fi
              
            #   # Reiniciar Docker
            #   echo "Restarting Docker daemon..."
            #   if sudo systemctl restart docker 2>/dev/null; then
            #     echo "Docker restarted successfully using systemctl"
            #   elif sudo service docker restart 2>/dev/null; then
            #     echo "Docker restarted successfully using service"
            #   else
            #     echo "Warning: Failed to restart Docker. Please restart manually." >&2
            #   fi
            #   echo "Waiting for Docker to be ready..."
            #   sleep 5
            # fi
            
            # Push para o registry
            echo "Pushing to registry \$REGISTRY..."
            sudo docker push \$REGISTRY/$CONTAINER_NAME:latest
            sudo docker push \$REGISTRY/$CONTAINER_NAME:$COMMIT_SHA
            
            # Mover .env para o diretório do projeto
            mv /tmp/.env .env
            
            # Limpar arquivos temporários e imagens não utilizadas
            rm -f /tmp/$CONTAINER_NAME.tar.gz
            echo "Cleaning unused Docker images..."
            sudo docker image prune -af --filter "until=24h"
          EOF
      
      - name: Cleanup SSH
        if: always()
        run: |
          rm -rf ~/.ssh/id_rsa
  
  deploy:
    name: Deploy Docker Container
    runs-on: ubuntu-latest
    needs: build
    # Executar deploy apenas se não for build-only
    if: |
      github.event_name != 'workflow_dispatch' || 
      github.event.inputs.action_type != 'build-only'
    
    # Requer aprovação para deploys de PRD
    # DEV → 'development' (sem aprovação), PRD/push → 'production' (requer aprovação)
    environment:
      name: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'DEV') && 'development' || 'production' }}
    
    permissions:
      contents: read
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
      
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=PRD" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy on VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          REGISTRY_HOST: ${{ secrets.REGISTRY_HOST || secrets.VPS_HOST }}
          REGISTRY_PORT: ${{ secrets.REGISTRY_PORT || '5000' }}
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          # Determinar container e porta com base no ambiente
          if [ "$ENVIRONMENT" == "DEV" ]; then
            CONTAINER_NAME="azevedo-site-dev"
            PORT="3001"
          else
            CONTAINER_NAME="azevedo-site"
            PORT="3000"
          fi
          
          REGISTRY="${REGISTRY_HOST}:${REGISTRY_PORT}"
          
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST << EOF
            set -e
            
            # Navegar para o diretório do projeto
            if [ "$ENVIRONMENT" == "DEV" ]; then
              cd $VPS_PATH/dev
            else
               cd $VPS_PATH
            fi
           
            
            # Parar containers usando docker-compose
            if [ -f docker-compose.yml ] || [ -f docker-compose.yaml ]; then
              echo "Stopping containers with docker-compose..."
              sudo docker-compose down || true
            else
              echo "No docker-compose file found, stopping containers manually..."
              if sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}\\$"; then
                echo "Stopping existing container: $CONTAINER_NAME"
                sudo docker stop $CONTAINER_NAME || true
                sudo docker rm $CONTAINER_NAME || true
              fi
            fi
            
            # Pull da imagem do registry
            echo "Pulling latest image from registry..."
            sudo docker pull $REGISTRY/azevedo-site:latest
            
            # Definir variáveis de ambiente para o docker-compose
            export CONTAINER_NAME=$CONTAINER_NAME
            export PORT=$PORT
            export IMAGE_TAG=latest
            export REGISTRY=$REGISTRY
            
            # Executar usando docker-compose
            if [ -f docker-compose.yml ] || [ -f docker-compose.yaml ]; then
              echo "Starting containers with docker-compose..."
              sudo -E docker-compose up -d
              
              # Aguardar o container ficar disponível
              echo "Waiting for containers to be ready..."
              sleep 10
              
              # Executar migrations do Prisma via docker-compose
              echo "Running Prisma migrations..."
              if sudo docker-compose exec -T web npx prisma migrate deploy; then
                echo "✓ Migrations completed successfully"
              else
                echo "⚠ Warning: Migrations failed or no migrations to run"
              fi
            else
              echo "No docker-compose file found, falling back to manual container creation..."
              sudo docker run -d \
                --name $CONTAINER_NAME \
                -p $PORT:3000 \
                --env-file .env \
                --restart unless-stopped \
                $REGISTRY/azevedo-site:latest
              
              # Executar migrations do Prisma
              echo "Running Prisma migrations..."
              if sudo docker exec $CONTAINER_NAME npx prisma migrate deploy; then
                echo "✓ Migrations completed successfully"
              else
                echo "⚠ Warning: Migrations failed or no migrations to run"
              fi
            fi
          EOF
      
      - name: Verify Deployment
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST "sudo docker ps | grep azevedo-site"
      
      - name: Cleanup SSH
        if: always()
        run: |
          rm -rf ~/.ssh/id_rsa
