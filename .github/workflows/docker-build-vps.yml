name: Build Docker on VPS

# Trigger do workflow
on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch: # Permite executar manualmente
    inputs:
      action_type:
        description: 'Tipo de ação a executar'
        required: true
        type: choice
        options:
          - build-and-deploy
          - build-only
        default: 'build-and-deploy'
      environment:
        description: 'Ambiente de deploy (DEV ou PRD)'
        required: true
        type: choice
        options:
          - PRD
          - DEV
        default: 'PRD'

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    
    # Definir permissões mínimas necessárias para o GITHUB_TOKEN
    permissions:
      contents: read  # Para fazer checkout do código
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
      
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Para push/PR, usar PRD por padrão
            echo "environment=PRD" >> $GITHUB_OUTPUT
          fi
      
      - name: Create .env file
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          
          # Selecionar secrets baseado no ambiente
          if [ "$ENV" == "DEV" ]; then
            DATABASE_URL="${{ secrets.DATABASE_URL_DEV || secrets.DATABASE_URL }}"
            NODE_ENV="development"
            API_KEY="${{ secrets.API_KEY_DEV || secrets.API_KEY }}"
            NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET_DEV || secrets.NEXTAUTH_SECRET }}"
            NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL_DEV || secrets.NEXTAUTH_URL }}"
          else
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
            NODE_ENV="${{ secrets.NODE_ENV || 'production' }}"
            API_KEY="${{ secrets.API_KEY }}"
            NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}"
            NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}"
          fi
          
          cat > .env << ENVEOF
          DATABASE_URL="${DATABASE_URL}"
          NODE_ENV="${NODE_ENV}"
          NEXT_TELEMETRY_DISABLED="${{ secrets.NEXT_TELEMETRY_DISABLED || '1' }}"
          ENVEOF
          
          # Adicionar secrets opcionais se estiverem definidos
          if [ -n "$NEXTAUTH_SECRET" ]; then
            echo "NEXTAUTH_SECRET=\"${NEXTAUTH_SECRET}\"" >> .env
          fi
          
          if [ -n "$NEXTAUTH_URL" ]; then
            echo "NEXTAUTH_URL=\"${NEXTAUTH_URL}\"" >> .env
          fi
          
          if [ -n "$API_KEY" ]; then
            echo "API_KEY=\"${API_KEY}\"" >> .env
          fi
      
      - name: Build Docker Image
        run: |
          docker build -t azevedo-site:${{ github.sha }} -t azevedo-site:latest .
      
      - name: Save and Transfer Docker Image to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
        run: |
          # Criar tarball da imagem
          docker save azevedo-site:latest | gzip > azevedo-site.tar.gz
          
          # Transferir imagem e .env para o VPS
          scp -i ~/.ssh/id_rsa azevedo-site.tar.gz $VPS_USER@$VPS_HOST:/tmp/
          scp -i ~/.ssh/id_rsa .env $VPS_USER@$VPS_HOST:/tmp/
      
      - name: Load Image and Push to Registry on VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          REGISTRY_HOST: ${{ secrets.REGISTRY_HOST || secrets.VPS_HOST }}
          REGISTRY_PORT: ${{ secrets.REGISTRY_PORT || '5000' }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST "bash -s" << EOF
            set -e
            
            # Navegar para o diretório do projeto
            cd "$VPS_PATH"
            
            # Carregar a imagem do tarball
            echo "Loading Docker image..."
            docker load < /tmp/azevedo-site.tar.gz
            
            # Taguear para o registry local
            REGISTRY="$REGISTRY_HOST:$REGISTRY_PORT"
            docker tag azevedo-site:latest \$REGISTRY/azevedo-site:latest
            docker tag azevedo-site:latest \$REGISTRY/azevedo-site:$COMMIT_SHA
            
            # Configurar registry como insecure (HTTP) se necessário
            REGISTRY_ADDR="$REGISTRY_HOST:$REGISTRY_PORT"
            
            # Verificar se já está configurado
            if [ -f /etc/docker/daemon.json ] && grep -q "\"$REGISTRY_ADDR\"" /etc/docker/daemon.json 2>/dev/null; then
              echo "Registry $REGISTRY_ADDR already configured as insecure"
            else
              echo "Configuring Docker to allow insecure registry $REGISTRY_ADDR..."
              
              # Usar Python para manipular JSON de forma segura
              sudo python3 -c "
import json
import os
import sys

daemon_json_path = '/etc/docker/daemon.json'
config = {}

try:
    # Ler configuração existente se houver
    if os.path.exists(daemon_json_path):
        with open(daemon_json_path, 'r') as f:
            config = json.load(f)
        # Fazer backup
        with open(daemon_json_path + '.bak', 'w') as f:
            json.dump(config, f, indent=2)
    
    # Adicionar registry à lista de insecure-registries
    if 'insecure-registries' not in config:
        config['insecure-registries'] = []
    
    if '$REGISTRY_ADDR' not in config['insecure-registries']:
        config['insecure-registries'].append('$REGISTRY_ADDR')
    
    # Salvar configuração
    os.makedirs(os.path.dirname(daemon_json_path), exist_ok=True)
    with open(daemon_json_path, 'w') as f:
        json.dump(config, f, indent=2)
    
    print('Successfully configured insecure registry')
except json.JSONDecodeError as e:
    print(f'Error: Invalid JSON in {daemon_json_path}: {e}', file=sys.stderr)
    print('Creating new daemon.json with default configuration', file=sys.stderr)
    config = {'insecure-registries': ['$REGISTRY_ADDR']}
    with open(daemon_json_path, 'w') as f:
        json.dump(config, f, indent=2)
except Exception as e:
    print(f'Error configuring Docker daemon: {e}', file=sys.stderr)
    sys.exit(1)
"
              
              # Reiniciar Docker
              echo "Restarting Docker daemon..."
              if sudo systemctl restart docker 2>/dev/null; then
                echo "Docker restarted successfully using systemctl"
              elif sudo service docker restart 2>/dev/null; then
                echo "Docker restarted successfully using service"
              else
                echo "Warning: Failed to restart Docker. Please restart manually." >&2
              fi
              echo "Waiting for Docker to be ready..."
              sleep 5
            fi
            
            # Push para o registry
            echo "Pushing to registry \$REGISTRY..."
            docker push \$REGISTRY/azevedo-site:latest
            docker push \$REGISTRY/azevedo-site:$COMMIT_SHA
            
            # Mover .env para o diretório do projeto
            mv /tmp/.env .env
            
            # Limpar arquivos temporários e imagens não utilizadas
            rm -f /tmp/azevedo-site.tar.gz
            echo "Cleaning unused Docker images..."
            docker image prune -af --filter "until=24h"
          EOF
      
      - name: Cleanup SSH
        if: always()
        run: |
          rm -rf ~/.ssh/id_rsa
  
  deploy:
    name: Deploy Docker Container
    runs-on: ubuntu-latest
    needs: build
    # Executar deploy apenas se não for build-only
    if: |
      github.event_name != 'workflow_dispatch' || 
      github.event.inputs.action_type != 'build-only'
    
    # Requer aprovação para deploys de PRD
    # DEV → 'development' (sem aprovação), PRD/push → 'production' (requer aprovação)
    environment:
      name: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'DEV') && 'development' || 'production' }}
    
    permissions:
      contents: read
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
      
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=PRD" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy on VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          REGISTRY_HOST: ${{ secrets.REGISTRY_HOST || secrets.VPS_HOST }}
          REGISTRY_PORT: ${{ secrets.REGISTRY_PORT || '5000' }}
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          # Determinar container e porta com base no ambiente
          if [ "$ENVIRONMENT" == "DEV" ]; then
            CONTAINER_NAME="azevedo-site-container-dev"
            PORT="3001"
          else
            CONTAINER_NAME="azevedo-site-container"
            PORT="3000"
          fi
          
          REGISTRY="${REGISTRY_HOST}:${REGISTRY_PORT}"
          
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST << EOF
            set -e
            
            # Navegar para o diretório do projeto
            cd $VPS_PATH
            
            # Parar e remover container antigo
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
            
            # Pull da imagem do registry e executar novo container
            docker pull \$REGISTRY/azevedo-site:latest
            docker run -d \
              --name $CONTAINER_NAME \
              -p $PORT:3000 \
              --env-file .env \
              --restart unless-stopped \
              \$REGISTRY/azevedo-site:latest
            
            # Executar migrations do Prisma
            echo "Running Prisma migrations..."
            if docker exec $CONTAINER_NAME npx prisma migrate deploy; then
              echo "✓ Migrations completed successfully"
            else
              echo "⚠ Warning: Migrations failed or no migrations to run"
            fi
          EOF
      
      - name: Verify Deployment
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          ssh -i ~/.ssh/id_rsa $VPS_USER@$VPS_HOST "docker ps | grep azevedo-site-container"
      
      - name: Cleanup SSH
        if: always()
        run: |
          rm -rf ~/.ssh/id_rsa
